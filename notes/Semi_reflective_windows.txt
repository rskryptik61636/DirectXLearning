Semi reflective windows

- First task after a long hiatus, try to implement the semi-reflective window scenario which threw the game company interview for yours truly!!!

- Rough outline
	- First just render the wall and objects on the other side of the window.
	
	- Render the window first as just a transparent object to simulate a window without reflections.
	
	- Try to simulate the semi-reflective window effect by playing with the mirror concept using the stencil buffer.
	
- Lets get started shall we! First, let's exhume the learning framework...
	- There's quite a bit of useful stuff and quite a bit of overly complicated stuff, lets see if we can sort through this mess and figure out how to make it simpler to use.
	
	- Might make sense to review some new C++ 11 functionality and design stuff before proceeding.
	
	- Can get lost in doing this learning process, might as well dive in and start learning about stuff as/when it becomes necessary...
	
	- As mentioned previously, there's quite a bit of stuff that can be re-used. We want a framework with a lot of loose functions that can be invoked in whatever order we need them 
	  to begin with and the architecture can then be built up as we go along.
	  
	- Keep going around in circles, simple way to start off seems to be to break down the tiled deferred shading implementation so that we can get an idea of how to refactor the DXApp/D3DApp
	  classes and all the other utils to make them easier to use.
	  
	- Getting nowhere fast, dump the refactoring for now. Just build an app with what we have and go from there...
	
- First steps
	- Create a template .h/.cpp file which represents a child class of DXApp by ccping DXApp and defining all the pure virtual methods as well as inserting TODOs wherever necessary.
	
	- What shaders do we need?
		- Basic phong shader should suffice.
		
		- Consider moving the shader functions out of the DXEffect class into the DXShaderUtils.(h/cpp) files so that they can be invoked directly by an app without having to create a separate effect.
		
		- Rather, might be useful to create a shader base class which contains all the common functionality and which can be extended for implementing different shaders.
		
		- The shader base class can containing the following functions from DXEffect:
			- getShaderByteCode
			
			- createConstantBuffer
			
			- populateConstantBufferData
			
			- createStructuredBuffer
			
			- all set* functions
			
			- constructShaderPath
			
		- The following are vertex shader specific and can be moved to the vertex shader class:
			- getInputLayout accessor function.
		
			- createInputLayoutFromShaderInfo
			
		- Each class will need the following additional function.
			- getShader(): Returns the ID3D11<whatever>Shader* object so that it can be bound to the pipeline.
			
		- Another idea. The base class can have the following public interface:
			- ctor takes in path to the shader file and pointer to the device context.
			
			- Pure virtual apply() method that each derived class has to implement. All the pipeline binding can be done in the apply method.
			  It allows the shader class to set the pipeline exactly the way it expects which helps avoid leaving the pipeline in a bad state.
			  
		- Furthermore, classes for each type of shader can be derived from the shader base class which contain specific functionality to
	      that shader type.
		  
		- Finally, concrete shader implementations will contain the shader variables that clients will set and the apply method will be implemented
		  to set the pipeline stages up appropriately.
		  
		- Moved all the resource and constant buffer structs from DXEffect.h to DXShaderUtils.h.
		
		- Might make sense to have a separate header/cpp file for these shader classes called DXShaders.(h/cpp)
		
		- constructShaderPath would be more useful as a standalone function in DXShaderUtils.h.
		
		- Actually, constructShaderPath can be called internally by concrete shader classes to construct the shader path appropriately. Revert back to how it was.
		
		- Accessor functions for the shader file path and byte code would be useful. On second thought, maybe not.
		
		- The best part is that we may not need class members to represent constant shader variables as we should be able to copy those in directly. Probably a good
		  idea to have mutator functions to set shader variables.
		  
		- It might be helpful to split the apply method into a number of set methods like so:
			- setConstants: set per frame and/or per object constants. The params can vary from shader to shader.
			- setResources: like the name says.
			- setSamplers: also like the name says.
			
		- There are a lot of 'common' header files strewn throughout the shader files. Might be useful to consolidate them into a few no. of headers.
			- dataTypes.hlsli: Contains all vertex types and associated data structures.
			- mathUtils.hlsli: Contains all math related functionality.
			- shadingUtils.hlsli: Contains the bulk of lighthelper.fx and other shading related functionality.
			- (not required) physicsUtils.hlsli: Contains all intersection code and associated functionality. On second thought, this can probably be combined with mathUtils.hlsli.
			
		- It may make sense to keep the global variables within each shader file for now because we don't want cross contamination caused by having them in header files.
		
		- Onwards to writing the basic shading classes...
	
	- Vertex layout?
		- Whatever fits the wall and mirror room objects.
	
	- Resources/States?
	
	- Scene objects?
		- Consider modifying the RoomV1 class a bit so that the vertex/index buffer info is exposed such that the pipeline stage binding and the drawing can be handled by the app.
		
		- The current method of having the aforementioned tasks happen inside the object class seems a bit restrictive and cumbersome.
		
		- Can return the following of each object:
			- no. of vertices
			
			- vertices start index
			
		- Rather it might make sense to have methods which do the following:
			- Bind the main vertex buffer.
			
			- Draw each object individually or in groups as necessary (wall, floor, room)
			
		- The SceneBuilder class can actually be expanded upon. It already has quite a bit of functionality implemented.